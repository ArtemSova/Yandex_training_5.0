#include <iostream>

using namespace std;

int main() {
	int n;
    cin >> n;

    short wheel[n];
    for(short i = 0; i < n; i++) {
        short num;
        cin >> num;
        wheel[i] = num;
    }

    int a;     // min начальная скорость колеса
    int b;     // max начальная скорость колеса
    int k;     // уменьшение скорости при прохождении одного сектора
    cin >> a >> b >> k;

    short answer = 0;

    long long full_circle;      // скорость, необходимая для прохождения полного круга колеса
    full_circle = 1U*n*k;       // (1U использ при умножении для защиты от переполнения) short * int, получаем long long

    if ((b - a) >= full_circle) {      // разница скоростей больше или равна тй, что необходима для прохождения полного оборота
        answer = wheel[0];               // т.е. на разных скоростях колесо останоится на каждом секторе
        for (short j = 0; j < n; j++) {    // берем максимальное значение
            if (wheel[j] > answer) answer = wheel[j];
        }
    }
    else {
        long long y = 1U*n*k; // скорость, необходимая для прохождения полного круга
        // (1U использ при умножении для защиты от переполнения) short * int, получаем long long

        if (a > y) {           // min скорость позволяет пройти больше полного круга
            int x = a - a%y;   // скорость затраченая на прохождение всех полных кругов
            a -= x;            // остаточная min скорость после прохождения всех полных кругов
            b -= x;            // остаточная max скорость после прохождения всех полных кругов
        }

        if (a > k and k > 2) {     // min скорость больше замедления и замедление больше 2
            if (k != 1) {                 // если k==1, x будет 0, а на 0 делить нельзя, оставляем всё как есть
                int x = k / 2;     // уменьшаем замедление до двух и подгоняем скрости под новое замедление
                a = a / x;         // min скорость стала меньше в x раз
                b = b / x;         // max скорость стала меньше в x раз
                k = 2;             // замедление скорость стало меньше в x раз
            }
        }
        else if (a < k and k > 2) {     // min скорость меньше замедления и замедление больше 2
            if (a != 1) {                        // если a==1, x будет 0, а на 0 делить нельзя, оставляем всё как есть
                int x = a / 2;          // уменьшаем min скорость до 2
                b = b / x;              // max скорость стала меньше в x раз
                k = k / x;              // замедление скорость стало меньше в x раз
                a = 2;                  // min скорость стала меньше в x раз
            }
        }

        for (int i = a; i < (b+1); i++) {             // перебираем оставшиеся скорости
            int position = i/k;                       // позиция остановки для текущей скорости
            if (i%k == 0) position -= 1;             // позиц кратна замедлению, то есть остаточная скорость == k,
            // снимаем одну позицию, так как на нее колесо уже не повернется (speed <= k) по условию
            if (position >= n) position -= n;         // позиция вышла за пределы шкалы, возвращаем ее в пределы
            if (wheel[position] > answer) answer = wheel[position];      // позиция по часовой стрелке
            if (position != 0) {                                         // нулевая уже проверена
                if (wheel[n-position] > answer) answer = wheel[n-position];  // позиц против час стрелки
            }

        }
    }

    cout << answer;

	return 0;
}
